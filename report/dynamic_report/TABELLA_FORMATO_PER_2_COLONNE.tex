%! Author = DIEGO
%! Date = 20/02/2024

% Idea migliore e creare coppie di funzioni per ogni funzione che crea le tabelle di interesse
% e avere una forma per un documento latex che intenda usare tutta la pagina per intero e
% un altra forma per la rederizzazione su più pagine virtuli visualizzate sulla stessa pagina del pdf

% questa rappresenta la tabella per il confronto degli algoritmi
% da riuscire a formare per non avere problemi di spaziatura

\begin{table}[H]
    \centering
    \resizebox{\columnwidth}{!}{%
        \begin{tabular}{@{}c *{3}{p{3.0cm}}@{}}
            \toprule
            \multirow{2}{*}{Algorithms} & \multicolumn{3}{c}{Columns} \\
            \cmidrule(lr){2-4}
            & \multirow{2}{*}{\makecell{Precision - macro}} & \multirow{2}{*}{\makecell{Recall - macro}} & \multirow{2}{*}{\makecell{F1 - macro}} \\
            \addlinespace
            \cmidrule(lr){2-4}
            & & & \\
            CentroidVector & 0.58 & 0.69 & 0.71 \\
            \addlinespace[5pt]
            \midrule
            LinearPredictor & 0.375* & 0.421 & 0.517* \\
            \addlinespace[5pt]
            \midrule
            IndexQuery & \textbf{0.99}* & \underline{0.985} & \textbf{0.979}* \\
            \addlinespace[5pt]
            \midrule
            ClassifierRecommender & 0.723* & 0.792 & 0.799 \\
            \addlinespace[5pt]
            \midrule
            AmarDoubleSource & \underline{0.875}* & \textbf{1.0} & \underline{0.917} \\
            \addlinespace[5pt]
            \midrule
            \bottomrule
        \end{tabular}%
    }
    \caption{Comparison between algorithms (Part 1)}
    \label{tab:tabella1}
\end{table}

% questa invece rappresenta la tabella da ottenere per il resize rispetto al layout su più colonne del pdf di report
% della tabella delle statistiche condotto con i test

\begin{table}[H]
    \centering
    \resizebox{\columnwidth}{!}{%
        \begin{tabular}{@{}l r r@{}}
            \toprule
            \textbf{sys\_pair} & \makecell{\textbf{Precision - macro}} & \makecell{\textbf{Recall@5 - macro}} \\
            \cmidrule(lr){2-3}
            & \makecell{pvalue} & \makecell{pvalue} \\
            \midrule
            (CentroidVector, LinearPredictor)         &     9.505701e-281 &         0.002248 \\
            (CentroidVector, IndexQuery)              &     2.835562e-276 &         0.002316 \\
            (LinearPredictor, IndexQuery)             &      6.955147e-01 &         0.994123 \\
            (CentroidVector, ClassifierRecommender)   &      1.230000e-03 &         0.023000 \\
            (CentroidVector, AmarDoubleSource)        &      5.000000e-01 &         0.876350 \\
            (LinearPredictor, ClassifierRecommender)  &      1.570000e+00 &         1.450000 \\
            (LinearPredictor, AmarDoubleSource)       &      1.500000e+00 &         1.200000 \\
            (IndexQuery, ClassifierRecommender)       &      2.470000e-02 &         0.063215 \\
            (IndexQuery, AmarDoubleSource)            &      8.800000e-01 &         0.445425 \\
            (ClassifierRecommender, AmarDoubleSource) &      3.200000e-03 &         0.120970 \\
            \bottomrule
        \end{tabular}%
    }
    \caption{Relevance table - Precision - macro, Recall@5 - macro}
    \label{tab:tabella2}
\end{table}

% questa rappresenta la tabella per della rilevanza statistica per la coppia di sistemi a confronto
% e permette la corretta visulizzazione della tabella nella virtualizzazione del documento su due colonne

\begin{table}[H]
    \centering
    \resizebox{\columnwidth}{!}{%
        \begin{tabular}{lr}
            \toprule
            \textbf{Metrics} & \textbf{(CentroidVector, IndexQuery)} \\
            \midrule
            Precision - macro - statistic & $-3.55 \times 10^{1}$ \\
            Precision - macro - pvalue & $2.84 \times 10^{-276}$ \\
            Recall@5 - macro - statistic & $-3.05 \times 10^{0}$ \\
            Recall@5 - macro - pvalue & $2.32 \times 10^{-3}$ \\
            Precision@5 - macro - statistic & $-2.09 \times 10^{1}$ \\
            Precision@5 - macro - pvalue & $1.51 \times 10^{-96}$ \\
            F1 - macro - statistic & $-1.49 \times 10^{1}$ \\
            F1 - macro - pvalue & $2.42 \times 10^{-50}$ \\
            MSE - statistic & $-2.99 \times 10^{1}$ \\
            MSE - pvalue & $1.45 \times 10^{-95}$ \\
            MAE - statistic & $-2.49 \times 10^{1}$ \\
            MAE - pvalue & $2.42 \times 10^{-50}$ \\
            Gini - statistic & $-1.55 \times 10^{1}$ \\
            Gini - pvalue & $3.84 \times 10^{-276}$ \\
            R-Precision - macro - statistic & $-3.05 \times 10^{0}$ \\
            R-Precision - macro - pvalue & $7.00 \times 10^{0}$ \\
            \bottomrule
        \end{tabular}%
    }
    \caption{\textbf{CentroidVector and IndexQuery}}
    \label{tab:tabella3}
\end{table}

# possibile cambio
\begin{itemize}
\begin{table}[htbp]
\resizebox{\columnwidth}{!}{%
\begin{minipage}{\columnwidth}
\begin{itemize}
\item \begin{minipage}[t]{\linewidth}
  \texttt{network: <class 'clayrs.recsys.network_based_algorithm.amar.amar_network.AmarNetworkMerge'>}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{item\_fields: [{'plot': ['tfidf\_sk']}, {'plot': ['tfidf\_sk']}]}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{user\_fields: [{}, {}]}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{batch\_size: 512}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{epochs: 5}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{threshold: 4}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{additional\_opt\_parameters: \{'batch\_size': 512\}}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{train\_loss: <function binary\_cross\_entropy at 0x00000234EC9A3760>}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{optimizer\_class: <class 'torch.optim.adam.Adam'>}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{device: cuda:0}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{embedding\_combiner: \{'Centroid': \{\}\}}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{seed: None}
\end{minipage}
\item \begin{minipage}[t]{\linewidth}
  \texttt{additional\_dl\_parameters: \{\}}
\end{minipage}
\end{itemize}
\end{minipage}
}
\caption{Lista degli elementi}
\end{table}

# possibile altra soluzione

\begin{table}[htbp]
\resizebox{\columnwidth}{!}{%
\begin{minipage}{\columnwidth}
\begin{itemize}
\item \texttt{network: <class 'clayrs.recsys.network\_based\_algorithm.amar.amar\_network.AmarNetworkMerge'>}
\item \texttt{item\_fields: [\{'plot': ['tfidf\_sk']\}, \{'plot': ['tfidf\_sk']\}]}
\item \texttt{user\_fields: [ \{ \} , \{ \} ]}
\item \texttt{batch\_size: 512}
\item \texttt{epochs: 5}
\item \texttt{threshold: 4}
\item \texttt{additional\_opt\_parameters: \{'batch\_size': 512\}}
\item \texttt{train\_loss: <function binary\_cross\_entropy at 0x00000234EC9A3760>}
\item \texttt{optimizer\_class: <class 'torch.optim.adam.Adam'>}
\item \texttt{device: cuda:0}
\item \texttt{embedding\_combiner: \{'Centroid': \{\}\}}
\item \texttt{seed: None}
\item \texttt{additional\_dl\_parameters: \{\}}
\end{itemize}
\end{minipage}
}
\end{table}


"""
def generate_latex_table_pvalued(algorithms, stats_rel, comparison="", treshold_pvalue=0.5,
                                 decimal_place=3, column_width=3.0,
                                 max_columns_per_part=5, caption_for_table="Comparison between algorithms"):
    # Controllo per assicurarsi che max_columns_per_part non superi mai 10
    if max_columns_per_part > 10:
        max_columns_per_part = 10

    # Estrai le chiavi (nomi di colonne) dal primo dizionario
    first_algorithm = algorithms[0]
    column_names = list(next(iter(first_algorithm.values())).keys())
    num_columns = len(column_names)

    # Lista di metriche il cui punteggio migliore è quello minimo
    metrics_minimum_score = ['RMSE', 'MSE', 'MAE', 'Gini']

    # Dizionario dinamico per determinare i migliori punteggi
    best_metrics = {}

    # genera i due dizionari che terranno traccia dei due punteggi più alti migliori e dei
    # 2 punteggi più bassi migliori
    highest_best_metrics = find_highest_bests(algorithms, column_names, decimal_place)
    print(f"il dizionario con i migliori risultati per metrica crescenti {highest_best_metrics}")
    lowest_best_metrics = find_lowest_bests(algorithms, column_names, decimal_place)
    print(f"il dizionario con le migliori metriche più basse è {lowest_best_metrics}")

    # Calcola il numero di parti necessarie
    num_parts = -(-num_columns // max_columns_per_part)  # Divisione arrotondata per eccesso

    # Inizializza il codice LaTeX
    latex_code = ""

    # controllo degli indici del dataframe stats_ref
    print(f"gli indici sono:\n {stats_rel.index}\n")

    # controllo dei multi-indici di colonna del df stats_ref
    print(f"I multi indici di colonna sono_\n {stats_rel.columns}")

    for part_index in range(num_parts):
        # Calcola gli indici delle colonne per questa parte
        start_col_index = part_index * max_columns_per_part
        end_col_index = (part_index + 1) * max_columns_per_part
        current_column_names = column_names[start_col_index:end_col_index]

        # Calcola la larghezza totale della tabella
        total_width = len(current_column_names) * column_width + 1
        latex_code += "\\begin{table}[H]\n"  # changed [ht] to [H]
        latex_code += "\\centering\n"
        latex_code += "\\resizebox{\\textwidth}{!}{%\n"
        latex_code += "\\begin{tabular}{@{}c" + " *{" + str(len(current_column_names)) + "}{" + "p{" + str(
            column_width) + "cm}}@{}}\n"
        latex_code += "\\toprule\n"
        latex_code += "\\multirow{2}{*}{Algorithms} & \\multicolumn{" + str(
            len(current_column_names)) + "}{c}{Columns} \\\\\n"
        latex_code += "\\cmidrule{2-" + str(len(current_column_names) + 1) + "}\n"

        # Aggiungi i nomi delle colonne
        for col_index, column_name in enumerate(current_column_names):
            latex_code += "& \\multirow{2}{*}{\\makecell{" + column_name.replace("_", "\\_") + "}} "

        latex_code += "\\\\\n"
        latex_code += "\\addlinespace[5pt]\n"
        latex_code += "\\cmidrule{2-" + str(len(current_column_names) + 1) + "}\n"

        # Aggiungi i dati delle righe
        for algorithm in algorithms:
            algorithm_name = list(algorithm.keys())[0]
            print(f"algorithm name is {algorithm_name}")
            values = list(algorithm.values())[0]
            # print(f"values is  {values}")
            latex_code += algorithm_name
            for column_name in current_column_names:
                print(f"column value is {column_name}")
                # Verifica se la colonna è presente nel dizionario prima di accedere
                column_value = values.get(column_name, '')
                # Converte il valore in un numero (float) prima di arrotondarlo
                try:
                    column_value = float(column_value)
                    rounded_value = round(column_value, decimal_place)
                except (ValueError, TypeError):
                    # Se la conversione non è possibile, mantieni il valore come stringa
                    rounded_value = column_value

                # Determina quale dizionario utilizzare per ottenere i migliori punteggi
                best_metrics = highest_best_metrics if column_name not in metrics_minimum_score else lowest_best_metrics

                # Estrai i valori migliori per la colonna corrente
                best_values = best_metrics[column_name]

                # Formatta il valore in base ai risultati migliori
                if rounded_value == best_values[0]:
                    latex_code += " & \\textbf{" + str(rounded_value) + "}"
                elif rounded_value == best_values[1]:
                    latex_code += " & \\underline{" + str(rounded_value) + "}"
                else:
                    latex_code += " & " + str(rounded_value)

                # ATTENZIONE che qui viene usato l'import del modulo statistic_test_table as stt
                # Aggiungi asterisco se il p-value è inferiore al threshold
                access_index = stt.set_access_index(comparison, algorithm_name, column_name)
                # STAMPE DI CONTROLLO PER L'INDICE GENERATO
                print(f"access_index is {access_index} \n "
                      f"il primo elemento dell'indice è {access_index[0][0]} \n "
                      f"mentre il secondo è {access_index[1]}")

                # stampe per il controllo degli indici matchati
                if access_index[0][0] in stats_rel.index:
                    print(f"INDICE DI RIGA TROVATO OOOOK")

                if access_index[1] in stats_rel.columns:
                    print(f"MULTI INDICE DI COLONNA TROVATO OOOK")

                # Verifica se il multi-indice è presente tra le colonne del DataFrame stats_rel
                if access_index[1] in stats_rel.columns and access_index[0][0] in stats_rel.index:
                    val_retrieved = stats_rel.loc[access_index]
                    if not val_retrieved.empty:
                        float_pvalue = val_retrieved.iloc[0]
                        if float_pvalue < treshold_pvalue:
                            latex_code += "*"
                else:
                    # Secondo tentativo di accesso con i primi due parametri scambiati
                    access_index = stt.set_access_index(algorithm_name, comparison, column_name)
                    # Verifica se il multi-indice è presente tra le colonne del DataFrame stats_rel
                    if access_index[1] in stats_rel.columns and access_index[0][0] in stats_rel.index:
                        val_retrieved = stats_rel.loc[access_index]
                        if not val_retrieved.empty:
                            float_pvalue = val_retrieved.iloc[0]
                            if float_pvalue < treshold_pvalue:
                                latex_code += "*"
                    else:
                        # Gestisci il caso in cui entrambi gli indici non esistono
                        pass  # o fai qualcos'altro, a seconda del tuo caso d'uso

            latex_code += " \\\\\n"
            latex_code += "\\addlinespace[5pt]\n"
            latex_code += "\\midrule\n"

        # Aggiungi la parte finale del codice LaTeX
        latex_code += "\\bottomrule\n"
        latex_code += "\\end{tabular}}\n"
        latex_code += "\\caption{" + caption_for_table + " (Part " + str(part_index + 1) + ")}\n"
        latex_code += "\\end{table}\n"

        # Aggiungi alcune righe vuote tra le parti
        if part_index < num_parts - 1:
            latex_code += "\\vspace{10pt}\n"

    return latex_code
"""
