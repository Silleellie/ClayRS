%! Author = DIEGO MICCOLI
%! Date = 27/12/2023

\usepackage{comment}


###

\BLOCK{if 'interactions' in my_dict}
% ----------------------------------------- START RECSYS MODULE ------------------------------------------------------
\section{Recommender System module: RecSys}\label{sec:recsys}
The \textbf{RecSys module} allows to instantiate a recommender system and make it work on items and users serialized
by the Content Analyzer module, despite this is also possible using other serialization made with other framework and
give them as input to the recommender system and obtain score prediction or recommend items for the active user(s).
In particular this module allows has to get some general statistics on the data used, the scheme used to split the data
and train the recommender system and the settings beloning to the algorithm chosen.
\hfill\break
\hfill\break

\subsection{Statistics on data used}\label{subsec:stats}
% --- DATA STATS ---
In this experiment the statistics of the dataset used are reported in the following table:~\ref{tab:dataset_table}:
\begin{table}[ht]
    \centering
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Parameter}& \textbf{Value} \\ \hline
    n\_users  & \VAR{my_dict['interactions']['n_users']|default('no users')|safe_text}\\ \hline
    n\_items  & \VAR{my_dict['interactions']['n_items']|default('no items')|safe_text}\\ \hline
    total\_interactions  & \VAR{my_dict['interactions']['total_interactions']|safe_text}\\ \hline
    min\_score  & \VAR{my_dict['interactions']['min_score']|safe_text}\\ \hline
    max\_score  & \VAR{my_dict['interactions']['max_score']|safe_text}\\ \hline
    mean\_score  & \VAR{my_dict['interactions']['mean_score']|safe_text}\\ \hline
    sparsity  & \VAR{my_dict['interactions']['sparsity']|truncate|safe_text}\\ \hline
  \end{tabular}
   \caption{Table of the Interactions}\label{tab:dataset_table}
\end{table}
\hfill\break
\hfill\break


% ------------------------------ START SUBSECTION OF PARTITIONING OF RECSYS --------------------------------------------
\subsection{Partitioning techinque used}\label{subsec:partitioning}
\BLOCK{if my_dict['partitioning'] is defined and
        my_dict['partitioning']['KFoldPartitioning'] is defined}
% KFOLD PARTITIONING TECNIQUE
K-fold cross-validation is a technique used in machine learning to assess
the performance of a predictive model. The basic idea is to divide the dataset
into K subsets, or folds. The model is then trained K times, each time using K-1
folds for training and the remaining fold for validation. This process is
repeated K times, with a different fold used as the validation set in each iteration
\hfill\break
\hfill\break
The KFoldPartitioning has been used with the following setting:
\hfill\break
\hfill\break
The train set size of this experiment is the \VAR{my_dict['partitioning']['KFoldPartitioning']['train_set_size'] * 100}\%
of the original dataset, while the test set is the remaining \VAR{(100 - (my_dict['partitioning']['KFoldPartitioning']['train_set_size'] * 100))}\%.
\hfill\break
\hfill\break
\BLOCK{if my_dict.get('partitioning', {}).get('KFoldPartitioning', {}).get('shuffle') == True}
The data has been shuffled before being split into batches.
\BLOCK{endif}
The partitioning technique has been executed with the following settings:
\begin{itemize}
    \item number of splits: \VAR{my_dict['partitioning']['KFoldPartitioning']['n_splits']}
    \item shuffle: \VAR{my_dict['partitioning']['KFoldPartitioning']['shuffle']}
    \item random state: \VAR{my_dict['partitioning']['KFoldPartitioning']['random_state']|default('no random state applied')}
    \item skip user error: \VAR{my_dict['partitioning']['KFoldPartitioning']['skip_user_error']|default('no setted')}
\end{itemize}
\hfill\break
\hfill\break
% KFOLD PARTITIONING TECNIQUE ended
\BLOCK{endif}


\BLOCK{if my_dict['partitioning'] is defined and
        my_dict['partitioning']['HoldOutPartitioning'] is defined}
%  HOLD-OUT PARTIONING TECNIQUE
The partitioning used is the Hold-Out Partitioning.
This approach splits the dataset in use into a train set and a test set.
The training set is what the model is trained on, and the test set is used to see how
well the model will perform on new, unseen data.
\hfill\break
\hfill\break
The train set size of this experiment is the \VAR{my_dict['partitioning']['HoldOutPartitioning']['train_set_size'] * 100}\%
of the original dataset, while the test set is the remaining \VAR{(100 - (my_dict['partitioning']['HoldOutPartitioning']['train_set_size'] * 100))}\%.
\hfill\break
\hfill\break
\BLOCK{ if my_dict.get('partitioning', {}).get('HoldOutPartitioning', {}).get('shuffle') == True }
The data has been shuffled before being split into batches.
\BLOCK{endif}
\hfill\break
\hfill\break
%  HOLD-OUT PARTIONING TECNIQUE ended
\BLOCK{endif}
% end partitioning section___________


% ---------------------------------- ALGORITHM FOR RECOMMENDER SYSTEM -------------------------------------------------
\subsection{Algorithm used for the recommender system}\label{subsec:algo}
% ---RECSYS ALGORITHM ---
The framework of ClayRs allows to instantiate a recommender system in order to make list of recommendation, to achieve
this target the system need to be based on a chosen algorithm that will work with the representation of data that
we have.
In this section we will analyse which algorithm has been used for the experiment and what are the settings
given.
\hfill\break
\hfill\break

% Dealing with the principal class where the algorithm used belong to.
\BLOCK{if my_dict['recsys'] is defined and
        my_dict['recsys']['ContentBasedRS'] is defined}
The recommender system is based on content.
\hfill\break
\hfill\break
\BLOCK{elif my_dict['recsys'] is defined and
        my_dict['recsys']['GraphBasedRS'] is defined}
The recommender system is based on a graph representation.
\hfill\break
\hfill\break
\BLOCK{else}
Algorithm used is unknown.
\hfill\break
\hfill\break
\BLOCK{endif}

% ----------------------------------------- CONTENT BASE ALGO ---------------------------------------------------------
\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['ContentBasedRS'] is defined and
      my_dict['recsys']['ContentBasedRS']['algorithm']['AmarDoubleSource'] is defined}
% AMAR DOUBLE SOURCE ALGO
The algorithm used is AmarDoubleSource
\begin{itemize}
    \item item fields: 'list of field used' TO BE ADJUSTED
    \item user fields: TO BE ADJUSTED
    \item batch size: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['AmarDoubleSource']['batch_size']|default('no batch size') }
    \item epochs: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['AmarDoubleSource']['epochs']|default('no batch size')}
    \item threshold: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['AmarDoubleSource']['threshold']|default('no batch size')}
    \item embedding combiner: TO ADJUST
    \item seed: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['AmarDoubleSource']['seed']|default('no batch size')}
    \item additional dl parameters: TO ADJUST
\end{itemize}
\hfill\break
\hfill\break
The mode used is \VAR{ my_dict['recsys']['ContentBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['ContentBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% AmarDoubleSource end_____
\BLOCK{endif}


\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['ContentBasedRS'] is defined and
      my_dict['recsys']['ContentBasedRS']['algorithm']['CentroidVector'] is defined}
% CENTROID VECTOR ALGO
The algorithm used is the centroid vector
\begin{itemize}
    \item item fields: TO BE ADJUSTED
    \item user fields: TO BE ADJUSTED
    \item similarity:  \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['CentroidVector']['similarity']|default('no similarity')|safe_text}
    \item threshold: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['CentroidVector']['threshold']|default('no threshold')}
    \item embedding combiner: TO ADJUST
\end{itemize}
\hfill\break
\hfill\break
The mode used is \VAR{ my_dict['recsys']['ContentBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['ContentBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% centroid vector end____
\BLOCK{endif}


\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['ContentBasedRS'] is defined and
      my_dict['recsys']['ContentBasedRS']['algorithm']['ClassifierRecommender'] is defined}
% CLASSIFIER ALGO
The algorithm used is a classifier \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['ClassifierRecommender']['classifier']|safe_text)}
\begin{itemize}
    \item item fields: TO BE ADJUSTED
    \item user fields: TO BE ADJUSTED
    \item threshold: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['ClassifierRecommender']['threshold']|default('no threshold')}
    \item embedding combiner: TO ADJUST
\end{itemize}
\hfill\break
\hfill\break
The mode used is \VAR{ my_dict['recsys']['ContentBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['ContentBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% classifier end___
\BLOCK{endif}


\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['ContentBasedRS'] is defined and
      my_dict['recsys']['ContentBasedRS']['algorithm']['IndexQuery'] is defined}
% INDEX QUERY ALGO
The algorithm used is the Index Query.
\begin{itemize}
    \item item fields: TO BE ADJUSTED
    \item user fields: TO BE ADJUSTED
    \item classic similarity: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['IndexQuery']['classic_similarity']|default('no used')}
    \item threshold: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['IndexQuery']['threshold']|default('no threshold')}
    \item embedding combiner: TO ADJUST
\end{itemize}
\hfill\break
\hfill\break
The mode used is \VAR{ my_dict['recsys']['ContentBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['ContentBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% index query end____
\BLOCK{endif}


\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['ContentBasedRS'] is defined and
      my_dict['recsys']['ContentBasedRS']['algorithm']['LinearPredictor'] is defined}
% LINEAR PREDICTOR ALGO
The algorithm used is a regressor \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['LinearPredictor']['regressor']|safe_text)}
\begin{itemize}
    \item item fields: TO BE ADJUSTED
    \item user fields: TO BE ADJUSTED
    \item only greater eq: \VAR{my_dict['recsys']['ContentBasedRS']['algorithm']['LinearPredictor']['only_greater_eq']|default('no used')}
    \item embedding combiner: TO ADJUST
\end{itemize}
\hfill\break
\hfill\break
The mode used is \VAR{ my_dict['recsys']['ContentBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['ContentBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% linear predictor end____
\BLOCK{endif}


% ------------------------ GRAPH BASED ALGO ------------------------------------------
\BLOCK{if my_dict['recsys'] is defined and
      my_dict['recsys']['GraphBasedRS'] is defined and
      my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank'] is defined}
% NX PAGE RANK ALGO
The algorithm used is NX Page Rank.
\begin{itemize}
    \item alpha: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['alpha']|default('no alpha used')}
    \item personalized: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['personalized']|default('no used')}
    \item max iter: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['max_iter']|default('no max iter')}
    \item tol: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['tol']|default('no used')}
    \item nstart: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['nstart']|default('no used')}
    \item weight: \VAR{my_dict['recsys']['GraphBasedRS']['algorithm']['NXPageRank']['weight']|default('no used')|safe_text}
\end{itemize}
\hfill\break
\hfill\break
The type of graph used in the algorithm is a: \VAR{ my_dict['recsys']['GraphBasedRS']['graph']},
the mode used is \VAR{ my_dict['recsys']['GraphBasedRS']['mode']} and the number of recommendation given is
\VAR{ my_dict['recsys']['GraphBasedRS']['n_recs']|default('no number has been setted')}.
\hfill\break
\hfill\break
% NX page rank end____
\BLOCK{endif}


% In case of the RecSys in not been used
\BLOCK{else}
The RecSys module has not been used during this experiment.
\hfill\break
\hfill\break
% <------------------ RECSYS SECTION ENDED------------------->
\BLOCK{endif}

###


\begin{comment}
Author = DIEGO MICCOLI
Alias = Kozen88
Organization = SWAP Research Group UniBa
Date = 27-12-2023

This mini template is not working by itself because there are latex command missing needed
to compile the file and give as output a pdf file, in addition it has been added jinja
statement in order to control the rendering of the latex file with the jinja library, for these
reasons it needs to be used with the other mini chunks in conjunction.
\end{comment}